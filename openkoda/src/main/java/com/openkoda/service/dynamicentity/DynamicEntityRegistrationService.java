package com.openkoda.service.dynamicentity;

import aj.org.objectweb.asm.Opcodes;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.openkoda.core.flow.LoggingComponent;
import com.openkoda.core.form.FieldType;
import com.openkoda.core.form.FrontendMappingDefinition;
import com.openkoda.core.form.FrontendMappingFieldDefinition;
import com.openkoda.core.service.form.FormService;
import com.openkoda.dto.CanonicalObject;
import com.openkoda.model.common.OpenkodaEntity;
import com.openkoda.model.common.SearchableRepositoryMetadata;
import com.openkoda.model.component.Form;
import com.openkoda.model.file.File;
import com.openkoda.repository.SearchableRepositories;
import com.openkoda.repository.SecureRepository;
import jakarta.persistence.*;
import net.bytebuddy.ByteBuddy;
import net.bytebuddy.description.annotation.AnnotationDescription;
import net.bytebuddy.description.modifier.ModifierContributor;
import net.bytebuddy.description.modifier.TypeManifestation;
import net.bytebuddy.description.modifier.Visibility;
import net.bytebuddy.description.type.TypeDescription;
import net.bytebuddy.dynamic.DynamicType;
import net.bytebuddy.implementation.FieldAccessor;
import net.bytebuddy.implementation.MethodCall;
import org.apache.commons.lang.StringUtils;
import org.hibernate.annotations.Formula;
import org.springframework.data.jpa.repository.support.JpaRepositoryFactory;
import org.springframework.stereotype.Repository;
import org.springframework.stereotype.Service;
import reactor.util.function.Tuple2;
import reactor.util.function.Tuple4;
import reactor.util.function.Tuples;

import java.io.IOException;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.net.URISyntaxException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.*;

import static com.openkoda.core.helper.NameHelper.toColumnName;
import static com.openkoda.model.common.ModelConstants.REQUIRED_READ_PRIVILEGE;
import static com.openkoda.model.common.ModelConstants.REQUIRED_WRITE_PRIVILEGE;
import static java.lang.Character.isUpperCase;
import static java.util.stream.Collectors.toMap;
import static net.bytebuddy.description.modifier.Visibility.PROTECTED;
import static net.bytebuddy.description.modifier.Visibility.PUBLIC;
import static net.bytebuddy.dynamic.loading.ClassLoadingStrategy.Default.INJECTION;
import static net.bytebuddy.implementation.attribute.AnnotationValueFilter.Default.SKIP_DEFAULTS;

/**
 * Byte Buddy-based runtime JPA entity class generation and ClassLoader registration service.
 * <p>
 * Core service orchestrating dynamic entity system. Generates Java bytecode for entity classes at runtime 
 * based on DynamicEntityDescriptor metadata. Uses Byte Buddy library to create classes with JPA annotations 
 * ({@code @Entity}, {@code @Table}, {@code @Column}, {@code @Id}, {@code @GeneratedValue}, {@code @Formula}, 
 * {@code @ManyToOne}, {@code @ManyToMany}), compiles to byte arrays, loads via custom ClassLoader injection, 
 * and registers with JPA EntityManagerFactory for persistence operations.
 * </p>
 * 
 * <h3>Complete Workflow</h3>
 * <ol>
 * <li><b>Descriptor Generation:</b> {@link #generateDynamicEntityDescriptors(List, Long)} converts Form entities 
 * to DynamicEntityDescriptor instances via {@code DynamicEntityDescriptorFactory}</li>
 * <li><b>Class Building:</b> {@link #buildAndLoadDynamicClasses(ClassLoader)} compiles descriptors to 
 * Byte Buddy {@code DynamicType.Unloaded} artifacts</li>
 * <li><b>Bytecode Generation:</b> Byte Buddy {@code DynamicType.Builder} creates classes with JPA annotations 
 * ({@code @Entity}/{@code @Table}), defines fields with {@code @Column}/{@code @Formula}, generates 
 * getters/setters, handles many_to_one references and file attachments</li>
 * <li><b>ClassLoader Loading:</b> {@code DynamicType.load(classLoader, INJECTION)} injects generated bytecode 
 * into ClassLoader</li>
 * <li><b>JPA Registration:</b> Classes become visible to EntityManagerFactory for persistence operations</li>
 * <li><b>Repository Synthesis:</b> {@link #createAndLoadDynamicRepository} generates Spring Data JPA 
 * SecureRepository interfaces</li>
 * <li><b>Repository Registration:</b> {@code JpaRepositoryFactory} creates concrete proxies, registers in 
 * {@code SearchableRepositories} by table name</li>
 * <li><b>Static Registry:</b> Generated classes stored in {@link #dynamicEntityClasses} and 
 * {@link #dynamicRepositoryClasses} maps for runtime access</li>
 * </ol>
 * 
 * <h3>Field Type Mapping</h3>
 * <p>Maps {@code FrontendMappingFieldDefinition} types to Java types and JPA column types:</p>
 * <ul>
 * <li>{@code FieldType.text} → {@code String.class} with VARCHAR</li>
 * <li>{@code FieldType.bigint} → {@code Long.class} with BIGINT</li>
 * <li>{@code FieldType.numeric} → {@code BigDecimal.class} with NUMERIC</li>
 * <li>{@code FieldType.boolean} → {@code Boolean.class} with BOOLEAN</li>
 * <li>{@code FieldType.date} → {@code LocalDate.class} with DATE</li>
 * <li>{@code FieldType.timestamp_w_tz} → {@code LocalDateTime.class} with TIMESTAMP WITH TIME ZONE</li>
 * <li>{@code FieldType.time_w_tz} → {@code LocalTime.class} with TIME WITH TIME ZONE</li>
 * <li>{@code FieldType.files} → {@code List<File>} with {@code @ManyToMany} + {@code @ElementCollection} pattern</li>
 * <li>{@code FieldType.many_to_one} → Dynamically resolved via {@code DynamicEntityDescriptorFactory.getInstanceByEntityKey()}</li>
 * </ul>
 * 
 * <h3>JPA Annotations Applied</h3>
 * <ul>
 * <li>{@code @Entity}: Marks class as JPA entity</li>
 * <li>{@code @Table(name=tableName)}: Maps to database table</li>
 * <li>{@code @Column(name=dbColumnName)}: Standard column mapping</li>
 * <li>{@code @Formula(value=sqlFormula)}: Computed fields using SQL expressions</li>
 * <li>{@code @ManyToOne}: Foreign key references to other dynamic entities</li>
 * <li>{@code @ManyToMany}: File attachments via file_reference join table</li>
 * <li>{@code @ElementCollection}: File ID collection for file references</li>
 * <li>{@code @JoinColumn}: Foreign key column configuration</li>
 * <li>{@code @JsonIgnore}: Prevents JSON serialization of file collections</li>
 * </ul>
 * 
 * <h3>Formula Generation</h3>
 * <p>Automatically generates description and search index formulas:</p>
 * <ul>
 * <li><b>descriptionFormula:</b> CONCATENATES text fields: {@code (''||id||' '||COALESCE(field1,'')||' '||...)}</li>
 * <li><b>searchIndexFormula:</b> CONCATENATES all searchable fields with labels: 
 * {@code (''||'id:'||id||' '||'field1:'||COALESCE(field1,'')||...)}</li>
 * </ul>
 * 
 * <h3>Repository Synthesis</h3>
 * <p>Creates Spring Data JPA SecureRepository interfaces with annotations:</p>
 * <ul>
 * <li>{@code @Repository}: Spring component registration</li>
 * <li>{@code @SearchableRepositoryMetadata}: Embeds entityClass, entityKey, searchIndexFormula, 
 * descriptionFormula for search functionality</li>
 * <li>Implements {@code SecureRepository<GeneratedEntity>} for privilege-enforced queries</li>
 * <li>Registered via {@code JpaRepositoryFactory.getRepository()} for proxy creation</li>
 * </ul>
 * 
 * <p><b>Thread Safety Warning:</b> {@link #generateDynamicEntityDescriptors} and 
 * {@link #buildAndLoadDynamicClasses} use unsynchronized static HashMap registries 
 * ({@link #dynamicEntityClasses}, {@link #dynamicRepositoryClasses}). NOT thread-safe during concurrent 
 * generation. Callers must synchronize external access to prevent race conditions and class loading conflicts. 
 * Designed for single-threaded application startup only.</p>
 * 
 * @author OpenKoda Team
 * @version 1.7.1
 * @since 1.7.1
 * @see net.bytebuddy.ByteBuddy
 * @see DynamicEntityDescriptor
 * @see DynamicEntityDescriptorFactory
 * @see com.openkoda.model.component.Form
 * @see OpenkodaEntity
 * @see SecureRepository
 * @see org.springframework.data.jpa.repository.support.JpaRepositoryFactory
 * @see SearchableRepositories
 * @see FrontendMappingFieldDefinition
 * @see FieldType
 */
@Service
public class DynamicEntityRegistrationService implements LoggingComponent {

    /**
     * Package prefix for all generated dynamic entity and repository classes.
     * <p>
     * All runtime-generated classes are created in the {@code com.openkoda.dynamicentity.generated} package
     * to isolate them from hand-written source code and enable efficient scanning.
     * </p>
     */
    public static final String PACKAGE = "com.openkoda.dynamicentity.generated.";
    
    /**
     * Static registry of generated repository classes mapped by database table name.
     * <p>
     * Key: Database table name (e.g., "user_profile")<br>
     * Value: Tuple2 containing:
     * <ul>
     * <li>T1: Lowercase entity class name (e.g., "userprofile_1234567890")</li>
     * <li>T2: Generated repository interface class implementing {@code SecureRepository<OpenkodaEntity>}</li>
     * </ul>
     * </p>
     * <p><b>Thread Safety:</b> NOT thread-safe. External synchronization required during concurrent access.
     * Populated by {@link #buildAndLoadDynamicClasses(ClassLoader)} during single-threaded startup.</p>
     * 
     * @see #buildAndLoadDynamicClasses(ClassLoader)
     * @see SecureRepository
     */
    public static Map<String, Tuple2<String, Class<? extends SecureRepository<? extends OpenkodaEntity>>>> dynamicRepositoryClasses = new HashMap<>();
    
    /**
     * Static registry of generated entity classes mapped by entity key.
     * <p>
     * Key: Entity key identifier from {@code DynamicEntityDescriptor.getEntityKey()}<br>
     * Value: Generated entity class extending {@link OpenkodaEntity}
     * </p>
     * <p><b>Thread Safety:</b> NOT thread-safe. External synchronization required during concurrent access.
     * Populated by {@link #buildAndLoadDynamicClasses(ClassLoader)} during single-threaded startup.</p>
     * 
     * @see #buildAndLoadDynamicClasses(ClassLoader)
     * @see OpenkodaEntity
     * @see DynamicEntityDescriptor
     */
    public static Map<String, Class<? extends OpenkodaEntity>> dynamicEntityClasses = new HashMap<>();

    /**
     * JPA EntityManager for repository factory creation and entity management.
     * <p>
     * Injected by Spring's {@code @PersistenceContext} annotation. Used by 
     * {@link #registerDynamicRepositories(boolean)} to create concrete repository instances
     * via {@code JpaRepositoryFactory}.
     * </p>
     */
    @PersistenceContext
    EntityManager em;
    
    //final static ObjectMapper om = new ObjectMapper().registerModule(new JSR310Module());

    /**
     * Registers dynamic repositories with {@code SearchableRepositories} using {@code JpaRepositoryFactory}.
     * <p>
     * Iterates through {@link #dynamicRepositoryClasses} map to create concrete Spring Data JPA repository 
     * instances. Each repository is instantiated via {@code JpaRepositoryFactory.getRepository()} using the 
     * injected {@link #em EntityManager}, then registered in {@code SearchableRepositories} by table name 
     * for runtime query execution.
     * </p>
     * <p>
     * Called after {@link #buildAndLoadDynamicClasses(ClassLoader)} during application bootstrap to complete 
     * the repository lifecycle: generation → loading → registration.
     * </p>
     * <p><b>JPA Integration:</b> Uses {@code @PersistenceContext} EntityManager and 
     * {@code JpaRepositoryFactory.getRepository()} to create proxied repository implementations with 
     * Spring Data query derivation and custom query method support.</p>
     * 
     * @param proceed Flag controlling registration execution. If {@code false}, method returns immediately 
     *                without performing registration. Typically driven by application startup logic to 
     *                conditionally enable dynamic entity system.
     * @see #buildAndLoadDynamicClasses(ClassLoader)
     * @see #dynamicRepositoryClasses
     * @see SearchableRepositories#registerSearchableRepository
     * @see JpaRepositoryFactory#getRepository(Class)
     */
    public void registerDynamicRepositories(boolean proceed){
        if(!proceed){
            return;
        }
        for(Map.Entry<String, Tuple2<String, Class<? extends SecureRepository<? extends OpenkodaEntity>>>> entry : dynamicRepositoryClasses.entrySet()) {
            String tableName = entry.getKey();
            Class<? extends SecureRepository<? extends OpenkodaEntity>> repositoryClass = entry.getValue().getT2();

            SearchableRepositories.registerSearchableRepository(tableName, new JpaRepositoryFactory(em).getRepository(repositoryClass));
        }
    }

    /**
     * Converts Form entities to {@code DynamicEntityDescriptor} instances for runtime entity generation.
     * <p>
     * Extracts {@code FrontendMappingDefinition} from each Form via {@code FormService.getFrontendMappingDefinition()}, 
     * then delegates to {@link #generateDynamicEntityDescriptors(List, Map, Long)} with pre-computed mapping 
     * definitions. Returns count of successfully generated descriptors for logging and monitoring.
     * </p>
     * <p>
     * This is a convenience method that automatically parses frontend mapping definitions from Form entities.
     * Use the overloaded version {@link #generateDynamicEntityDescriptors(List, Map, Long)} when definitions 
     * are already available to avoid redundant parsing.
     * </p>
     * <p><b>Thread Safety:</b> NOT thread-safe. External synchronization required for concurrent invocations.
     * Modifies static registries in {@code DynamicEntityDescriptorFactory}.</p>
     * 
     * @param forms List of Form entities from database containing field definitions and table names. 
     *              Each Form must have a valid {@code FrontendMappingDefinition} accessible via 
     *              {@code FormService.getFrontendMappingDefinition()}.
     * @param timeMillis Timestamp suffix for class versioning in milliseconds. Enables hot-reload by generating 
     *                   unique class names for each application restart (e.g., "FormEntity_1234567890"). 
     *                   Typically obtained via {@code System.currentTimeMillis()}.
     * @return Count of generated {@code DynamicEntityDescriptor} instances. Useful for startup logging 
     *         to verify descriptor generation completed successfully.
     * @see #generateDynamicEntityDescriptors(List, Map, Long)
     * @see DynamicEntityDescriptorFactory#create
     * @see FormService#getFrontendMappingDefinition
     * @see Form
     */
    public static int generateDynamicEntityDescriptors(List<Form> forms, Long timeMillis) {
        debugLogger.debug("[generateDynamicEntityDescriptors] forms to process: {}", forms.size());
        return generateDynamicEntityDescriptors(forms, forms.stream().collect(toMap(Form::getName, FormService::getFrontendMappingDefinition)), timeMillis);
    }

    /**
     * Converts Form entities to {@code DynamicEntityDescriptor} instances using pre-computed mapping definitions.
     * <p>
     * Iterates through Form entities, extracting field definitions from the provided 
     * {@code frontendMappingDefinitions} map. For each Form, creates a {@code DynamicEntityDescriptor} 
     * via {@code DynamicEntityDescriptorFactory.create()} with the form name, table name, field definitions, 
     * and timestamp suffix. Returns total count for verification.
     * </p>
     * <p>
     * This method is the core descriptor generation implementation. The single-parameter overload 
     * {@link #generateDynamicEntityDescriptors(List, Long)} delegates to this method after parsing 
     * mapping definitions.
     * </p>
     * <p><b>Thread Safety:</b> NOT thread-safe. External synchronization required for concurrent invocations.
     * Modifies static registries in {@code DynamicEntityDescriptorFactory}.</p>
     * 
     * @param forms List of Form entities from database. Each Form provides the name and table name for 
     *              the generated entity class.
     * @param frontendMappingDefinitions Map of form names to parsed {@code FrontendMappingDefinition} instances. 
     *                                   Keys must match {@code Form.getName()} to ensure correct field 
     *                                   extraction. Definitions contain field types, constraints, and SQL formulas.
     * @param timeMillis Timestamp suffix for class versioning in milliseconds. Appended to class names to 
     *                   enable hot-reload (e.g., "FormEntity_1234567890").
     * @return Count of generated {@code DynamicEntityDescriptor} instances. Should equal {@code forms.size()} 
     *         on successful execution.
     * @see #generateDynamicEntityDescriptors(List, Long)
     * @see DynamicEntityDescriptorFactory#create
     * @see FrontendMappingDefinition#getDbTypeFields
     */
    public static int generateDynamicEntityDescriptors(List<Form> forms, Map<String, FrontendMappingDefinition> frontendMappingDefinitions, Long timeMillis) {
        debugLogger.debug("[generateDynamicEntityDescriptors] forms to process: {}", forms.size());
        int generatedEntities = 0;

        for(Form form : forms) {
            String formName = form.getName();
            String tableName = form.getTableName();
            List<FrontendMappingFieldDefinition> fields = Arrays.asList(frontendMappingDefinitions.get(form.getName()).getDbTypeFields());
            DynamicEntityDescriptorFactory.create(formName, tableName, fields, timeMillis);
            generatedEntities++;
        }


        return generatedEntities;
    }

    /**
     * Builds and loads dynamic entity and repository classes into the specified ClassLoader.
     * <p>
     * Executes a three-phase process to transform {@code DynamicEntityDescriptor} instances into 
     * fully-loaded JPA entities and Spring Data repositories:
     * </p>
     * 
     * <h3>Phase 1: Create Unloaded Byte Buddy Artifacts</h3>
     * <p>
     * Iterates {@code DynamicEntityDescriptorFactory.loadableInstances()} to create unloaded 
     * {@code DynamicType.Unloaded} artifacts for all descriptors. Stores in a temporary map keyed by 
     * entityKey. Each unloaded type contains:
     * <ul>
     * <li>T1: {@code DynamicType.Unloaded<OpenkodaEntity>} - Byte Buddy bytecode artifact</li>
     * <li>T2: String - Generated description formula for entity display</li>
     * <li>T3: String - Generated search index formula for full-text search</li>
     * <li>T4: List&lt;String&gt; - Entity keys of many_to_one referenced types for dependency resolution</li>
     * </ul>
     * </p>
     * 
     * <h3>Phase 2: Load Entity Classes with Dependency Resolution</h3>
     * <p>
     * Loads all entity classes via {@code classLoader.load(INJECTION)}, resolving many_to_one inter-descriptor 
     * dependencies. For each descriptor:
     * <ol>
     * <li>Retrieves unloaded type and dependency list from temporary map</li>
     * <li>Includes referenced entity types via {@code DynamicType.include()} to ensure proper class loading order</li>
     * <li>Loads class into ClassLoader using {@code INJECTION} strategy (bytecode injection)</li>
     * <li>Stores loaded class in {@link #dynamicEntityClasses} static map</li>
     * </ol>
     * This phase handles circular dependencies and ensures referenced entity classes are available during loading.
     * </p>
     * 
     * <h3>Phase 3: Create and Load Repository Interfaces</h3>
     * <p>
     * Creates Spring Data JPA repository interfaces for all loaded entities. For each descriptor:
     * <ol>
     * <li>Retrieves loaded entity class from {@link #dynamicEntityClasses}</li>
     * <li>Calls {@link #createAndLoadDynamicRepository} to synthesize {@code SecureRepository} interface</li>
     * <li>Annotates repository with {@code @Repository} and {@code @SearchableRepositoryMetadata}</li>
     * <li>Loads repository interface into ClassLoader</li>
     * <li>Stores in {@link #dynamicRepositoryClasses} map with table name as key</li>
     * <li>Marks descriptor as loaded via {@code setLoaded(true)}</li>
     * </ol>
     * </p>
     * 
     * <p><b>Static Effect:</b> Populates {@link #dynamicEntityClasses} and {@link #dynamicRepositoryClasses} 
     * static maps. These registries are used by {@link #registerDynamicRepositories(boolean)} for JPA 
     * repository creation.</p>
     * 
     * <p><b>Dependency Resolution:</b> Handles many_to_one references by including referenced entity types 
     * via {@code DynamicType.include()}. Ensures proper class loading order when entities reference each other.</p>
     * 
     * <p><b>Thread Safety:</b> NOT thread-safe. External synchronization required for concurrent invocations.</p>
     * 
     * @param classLoader Custom ClassLoader for dynamic class injection. Typically Spring Boot's restart 
     *                    ClassLoader obtained from {@code Thread.currentThread().getContextClassLoader()} 
     *                    or {@code ApplicationContext}. Must support bytecode injection via Byte Buddy's 
     *                    {@code INJECTION} strategy.
     * @throws IOException If source file writing fails during development mode. Byte Buddy can optionally 
     *                     write generated .class files to disk for debugging.
     * @throws URISyntaxException If resource path resolution fails when resolving generated class locations.
     * @see #createDynamicEntityType(String, String, Collection)
     * @see #createAndLoadDynamicRepository
     * @see DynamicEntityDescriptorFactory#loadableInstances()
     * @see DynamicEntityDescriptor#setLoaded(boolean)
     * @see net.bytebuddy.dynamic.DynamicType.Unloaded#load(ClassLoader, net.bytebuddy.dynamic.loading.ClassLoadingStrategy)
     * @see net.bytebuddy.dynamic.DynamicType.Unloaded#include(DynamicType.Unloaded)
     */
    public static void buildAndLoadDynamicClasses(ClassLoader classLoader) throws IOException, URISyntaxException {
        debugLogger.debug("[buildAndLoadDynamicClasses]");
        Map<String, Tuple4<DynamicType.Unloaded<OpenkodaEntity>, String, String, List<String>>> unloadedClasses = new HashMap<>();

//        create unloaded types
        for (DynamicEntityDescriptor descriptor : DynamicEntityDescriptorFactory.loadableInstances()) {
            Tuple4<DynamicType.Unloaded<OpenkodaEntity>, String, String, List<String>> dynamicEntity = createDynamicEntityType(descriptor.getSuffixedEntityClassName(), descriptor.getTableName(), descriptor.getFields());
            unloadedClasses.put(descriptor.getEntityKey(), dynamicEntity);
        }

//        load all dynamic types
        for (DynamicEntityDescriptor descriptor : DynamicEntityDescriptorFactory.loadableInstances()) {
            Tuple4<DynamicType.Unloaded<OpenkodaEntity>, String, String, List<String>> dynamicClass = unloadedClasses.get(descriptor.getEntityKey());
            DynamicType.Unloaded<OpenkodaEntity> t1 = dynamicClass.getT1();
            for(String type : dynamicClass.getT4()) {
                Tuple4<DynamicType.Unloaded<OpenkodaEntity>, String, String, List<String>> includeType = unloadedClasses.get(type);
                if(includeType != null) {
                    t1.include(includeType.getT1());
                }
            }
            dynamicEntityClasses.put(descriptor.getEntityKey(), t1.load(classLoader, INJECTION).getLoaded());
            debugLogger.debug("[buildAndLoadDynamicClasses] loaded entity class for key: {}", descriptor.getEntityKey());
        }

//        create and load repositories for all dynamic types
        for (DynamicEntityDescriptor descriptor : DynamicEntityDescriptorFactory.loadableInstances()) {
            Tuple4<DynamicType.Unloaded<OpenkodaEntity>, String, String, List<String>> dynamicEntityTuple = unloadedClasses.get(descriptor.getEntityKey());
            Class<? extends SecureRepository<? extends OpenkodaEntity>> dynamicRepository = createAndLoadDynamicRepository(
                    dynamicEntityClasses.get(descriptor.getEntityKey()), //generated entity class
                    descriptor.getEntityKey(),
                    dynamicEntityTuple.getT2(), //description formula
                    dynamicEntityTuple.getT3(), //search index formula
                    descriptor.getSuffixedRepositoryName(),
                    classLoader);
            dynamicRepositoryClasses.put(descriptor.getTableName(), Tuples.of(descriptor.getSuffixedEntityClassName().toLowerCase(), dynamicRepository));
            descriptor.setLoaded(true);
            debugLogger.debug("[buildAndLoadDynamicClasses] loaded repository class for key: {}", descriptor.getEntityKey());
        }
    }

    /**
     * Creates a Byte Buddy {@code DynamicType.Unloaded} entity class with JPA annotations and field mappings.
     * <p>
     * Generates a complete JPA entity class at runtime with the following characteristics:
     * </p>
     * 
     * <h3>Class Structure</h3>
     * <ol>
     * <li>{@code @Entity} and {@code @Table(name=tableName)} annotations for JPA persistence</li>
     * <li>Extends {@link OpenkodaEntity} superclass for base entity functionality (id, timestamps)</li>
     * <li>Implements {@link CanonicalObjectInterceptor} interface for audit/notification formatting</li>
     * <li>Public final modifiers for security and immutability guarantees</li>
     * <li>Public no-arg constructor delegating to {@code OpenkodaEntity(Long)} superclass constructor</li>
     * </ol>
     * 
     * <h3>Field Generation and Annotations</h3>
     * <p>For each {@code FrontendMappingFieldDefinition}:</p>
     * <ul>
     * <li><b>Standard Fields:</b> Defines public field with appropriate Java type, annotates with 
     * {@code @Column(name=dbColumnName)} or {@code @Formula(value=sqlFormula)} for computed fields, 
     * generates JavaBean getter and setter methods</li>
     * <li><b>File Attachments ({@code FieldType.files}):</b> Creates two fields:
     *   <ul>
     *   <li>{@code List<File> files} with {@code @ManyToMany}, {@code @JoinTable}, {@code @JsonIgnore}, 
     *   {@code @OrderColumn} for file entity associations</li>
     *   <li>{@code List<Long> filesId} with {@code @ElementCollection}, {@code @CollectionTable}, 
     *   {@code @OrderColumn} for file ID storage</li>
     *   </ul>
     * </li>
     * <li><b>Many-to-One References ({@code FieldType.many_to_one}):</b> Resolves referenced entity via 
     * {@code DynamicEntityDescriptorFactory.getInstanceByEntityKey()}, creates lazy-loaded association field 
     * with {@code @ManyToOne} and {@code @JoinColumn(insertable=false, updatable=false)}</li>
     * <li><b>Formula Fields:</b> For fields with non-blank {@code sqlFormula}, annotates with 
     * {@code @Formula(value=(sqlFormula))} instead of {@code @Column}</li>
     * </ul>
     * 
     * <h3>Generated SQL Formulas</h3>
     * <p>Automatically constructs two formulas for entity display and search indexing:</p>
     * <ul>
     * <li><b>descriptionFormula:</b> Concatenates text fields for entity description:
     * {@code (''||id||' '||COALESCE(field1,'')||' '||COALESCE(field2,'')||...)}</li>
     * <li><b>searchIndexFormula:</b> Concatenates all searchable fields with labels:
     * {@code (''||'id:'||id||' '||'field1:'||COALESCE(field1,'')||' '||'field2:'||COALESCE(cast(field2 as varchar),'')||...)}</li>
     * </ul>
     * 
     * <h3>Privilege Fields</h3>
     * <p>Adds two protected fields with null {@code @Formula} annotations for security integration:</p>
     * <ul>
     * <li>{@code requiredReadPrivilege} - For read access control</li>
     * <li>{@code requiredWritePrivilege} - For write access control</li>
     * </ul>
     * <p>Both fields have getters implementing {@code FieldAccessor.ofBeanProperty()} for property access.</p>
     * 
     * <h3>Byte Buddy Details</h3>
     * <p>Uses {@code ByteBuddy.subclass()} with:</p>
     * <ul>
     * <li>{@code SKIP_DEFAULTS} attribute filtering to minimize generated bytecode size</li>
     * <li>{@code ModifierContributor} for visibility control (PUBLIC, PROTECTED)</li>
     * <li>{@code FieldAccessor.ofField()} for property accessors (getters/setters)</li>
     * <li>{@code MethodCall.invoke()} for constructor delegation to superclass</li>
     * </ul>
     * 
     * @param name Suffixed entity class name without package prefix. Format: "FormEntity_1234567890" where 
     *             timestamp suffix enables hot-reload. Full class name becomes 
     *             {@code com.openkoda.dynamicentity.generated.FormEntity_1234567890}.
     * @param tableName Database table name for {@code @Table(name=...)} annotation. Must match existing or 
     *                  to-be-created database table.
     * @param fields Collection of field definitions with types, constraints, and SQL formulas. Each field 
     *               is transformed into a JPA-annotated class field with getter/setter methods.
     * @return Tuple4 containing:
     *         <ul>
     *         <li>T1: {@code DynamicType.Unloaded<OpenkodaEntity>} - Unloaded Byte Buddy artifact ready for 
     *         ClassLoader injection</li>
     *         <li>T2: String - Generated description formula for entity display strings</li>
     *         <li>T3: String - Generated search index formula for full-text search</li>
     *         <li>T4: List&lt;String&gt; - Entity keys of referenced types for dependency resolution</li>
     *         </ul>
     * @see #buildAndLoadDynamicClasses(ClassLoader)
     * @see FrontendMappingFieldDefinition
     * @see OpenkodaEntity
     * @see CanonicalObjectInterceptor
     * @see DynamicEntityDescriptorFactory#getInstanceByEntityKey
     * @see net.bytebuddy.ByteBuddy#subclass(Class)
     * @see net.bytebuddy.dynamic.DynamicType.Builder
     */
    private static <O extends OpenkodaEntity> Tuple4<DynamicType.Unloaded<OpenkodaEntity>, String, String, List<String>> createDynamicEntityType(
            String name, String tableName, Collection<FrontendMappingFieldDefinition> fields) {
        debugLogger.debug("[createDynamicEntityType] {} {}", name, tableName);

        AnnotationDescription entity = AnnotationDescription.Builder.ofType(Entity.class)
                .build();
        AnnotationDescription.Builder formulaType = AnnotationDescription.Builder.ofType(Formula.class);
        AnnotationDescription formula = formulaType
                .define("value", "(null)")
                .build();
        AnnotationDescription tableAnnotation = AnnotationDescription.Builder.ofType(Table.class)
                .define("name", tableName)
                .build();
        AnnotationDescription.Builder columnAnnotation = AnnotationDescription.Builder.ofType(Column.class)
                .define("updatable", true)
                .define("insertable", true);
//        files annotations
        AnnotationDescription foreignKeyAnnotation = AnnotationDescription.Builder.ofType(ForeignKey.class)
                .define("value", ConstraintMode.NO_CONSTRAINT).build();
        AnnotationDescription.Builder joinColumnAnnotation = AnnotationDescription.Builder.ofType(JoinColumn.class);
        AnnotationDescription.Builder joinColumnNotUpdatable = joinColumnAnnotation.define("insertable", false)
                .define("updatable", false);

        TypeDescription joinColumnAnnotationType = AnnotationDescription.Builder.ofType(JoinColumn.class).build().getAnnotationType();
        AnnotationDescription jsonIgnoreAnnotation = AnnotationDescription.Builder.ofType(JsonIgnore.class).build();
        AnnotationDescription manyToManyAnnotation = AnnotationDescription.Builder.ofType(ManyToMany.class)
                .define("fetch", FetchType.LAZY).build();
        AnnotationDescription joinTableAnnotation = AnnotationDescription.Builder.ofType(JoinTable.class)
                .define("name", "file_reference")
                .define("foreignKey", foreignKeyAnnotation)
                .defineAnnotationArray("inverseJoinColumns", joinColumnAnnotationType, joinColumnAnnotation
                        .define("name", "file_id")
                        .build())
                .defineAnnotationArray("joinColumns", joinColumnAnnotationType, joinColumnAnnotation
                        .define("name", "organization_related_entity_id")
                        .define("insertable", false)
                        .define("updatable", false)
                        .build())
                .build();

        AnnotationDescription elementCollectionAnnotation = AnnotationDescription.Builder.ofType(ElementCollection.class)
                .define("fetch", FetchType.LAZY)
                .define("targetClass", Long.class).build();
        AnnotationDescription collectionTableAnnotation = AnnotationDescription.Builder.ofType(CollectionTable.class)
                .define("name", "file_reference")
                .defineAnnotationArray("joinColumns", joinColumnAnnotationType, joinColumnAnnotation
                        .define("name", "organization_related_entity_id")
                        .build())
                .define("foreignKey", foreignKeyAnnotation).build();
        AnnotationDescription orderColumnAnnotation = AnnotationDescription.Builder.ofType(OrderColumn.class)
                .define("name", "sequence").build();
        AnnotationDescription manyToOneAnnotation = AnnotationDescription.Builder.ofType(ManyToOne.class).build();

        DynamicType.Unloaded<OpenkodaEntity> entityType = null;
        StringBuilder descriptionFormula = new StringBuilder();
        StringBuilder searchIndexFormula = new StringBuilder();
        List<String> includeTypes = new ArrayList<>();

        try {
            DynamicType.Builder<OpenkodaEntity>  dynamicType;

                dynamicType = new ByteBuddy()
                        .with(SKIP_DEFAULTS)
                        .subclass(OpenkodaEntity.class)
                        .implement(CanonicalObjectInterceptor.class)
                        .modifiers(ModifierContributor.Resolver.of(Visibility.PUBLIC, TypeManifestation.FINAL).resolve())
                        .name(PACKAGE + name)
                        .annotateType(entity)
                        .annotateType(tableAnnotation)
                        .defineConstructor(PUBLIC)
                        .intercept(MethodCall
                                .invoke(OpenkodaEntity.class.getDeclaredConstructor(Long.class))
                                .with((Object) null));

            for(FrontendMappingFieldDefinition field : fields) {
                Type fieldJavaType = getFieldJavaType(field);
                String dbColumnName = toColumnName(field.getName());

                if (field.getType().equals(FieldType.files)) {
                    dynamicType = dynamicType.defineField("files", listOfType(File.class), PUBLIC)
                            .annotateField(manyToManyAnnotation)
                            .annotateField(joinTableAnnotation)
                            .annotateField(jsonIgnoreAnnotation)
                            .annotateField(orderColumnAnnotation)
                            .defineMethod("getFiles" , listOfType(File.class), PUBLIC).intercept(FieldAccessor.ofField("files"))
                            .defineMethod("setFiles", void.class, PUBLIC).withParameter(listOfType(File.class)).intercept(FieldAccessor.ofField("files"));
                    dynamicType = dynamicType.defineField(field.getName(), listOfType(Long.class), PUBLIC)
                            .annotateField(columnAnnotation.define("name", "file_id").build())
                            .annotateField(elementCollectionAnnotation)
                            .annotateField(collectionTableAnnotation)
                            .annotateField(orderColumnAnnotation)
                            .defineMethod("getFilesId", listOfType(Long.class), PUBLIC).intercept(FieldAccessor.ofField("filesId"))
                            .defineMethod("setFilesId", void.class, PUBLIC).withParameter(listOfType(Long.class)).intercept(FieldAccessor.ofField("filesId"));
                } else {
                    if (field.getType().getDbType().equals(FieldType.text.getDbType())) {
                        descriptionFormula.append("||' '||").append(String.format("COALESCE(%s,'')", dbColumnName));
                    }
                    if (field.getType().getDbType().getColumnType().equals(FieldType.text.getDbType().getColumnType())) {
                        searchIndexFormula.append("||' '||").append(String.format("'%s:'||COALESCE(%s,'')", field.getName(), dbColumnName));
                    } else if (field.getType().equals(FieldType.many_to_one)) {
                        searchIndexFormula.append("||' '||").append(String.format("'%s:'||COALESCE(cast (%s as varchar),'')", field.getName(), dbColumnName));

                        DynamicEntityDescriptor instanceByEntityKey = DynamicEntityDescriptorFactory.getInstanceByEntityKey(field.referencedEntityKey);
                        if(instanceByEntityKey != null) {
                            String referenceFieldName = StringUtils.substringBeforeLast(toColumnName(field.getName()), "_");
                            TypeDescription.Latent referenceTypeDescription = instanceByEntityKey.getTypeDescription();
                            includeTypes.add(field.referencedEntityKey);
                            dynamicType = dynamicType.defineField(referenceFieldName, referenceTypeDescription, Opcodes.ACC_PUBLIC)
                                    .annotateField(manyToOneAnnotation)
                                    .annotateField(joinColumnNotUpdatable.define("name", toColumnName(field.getName())).build())
                                    .defineMethod(getGetterName(referenceFieldName), referenceTypeDescription, PUBLIC).intercept(FieldAccessor.ofField(referenceFieldName))
                                    .defineMethod(getSetterName(referenceFieldName), void.class, PUBLIC).withParameter(referenceTypeDescription).intercept(FieldAccessor.ofField(referenceFieldName));
                        }
                    }
                    AnnotationDescription fieldDbAnnotation =
                    StringUtils.isNotBlank(field.sqlFormula) ?
                        formulaType.define("value", String.format("(%s)", field.sqlFormula)).build():
                        columnAnnotation.define("name", dbColumnName).build();

                    dynamicType = dynamicType.defineField(field.getName(), fieldJavaType, PUBLIC)
                                .annotateField(fieldDbAnnotation)
                                .defineMethod(getGetterName(field.getName()), fieldJavaType, PUBLIC).intercept(FieldAccessor.ofField(field.getName()))
                                .defineMethod(getSetterName(field.getName()), void.class, PUBLIC).withParameter(fieldJavaType).intercept(FieldAccessor.ofField(field.getName()));
                }
            }
             entityType = dynamicType
                     .defineField(REQUIRED_READ_PRIVILEGE, String.class, PROTECTED)
                     .annotateField(formula)
                     .defineField(REQUIRED_WRITE_PRIVILEGE, String.class, PROTECTED)
                     .annotateField(formula)
                     .defineMethod("getRequiredReadPrivilege", String.class, PUBLIC)
                     .intercept(FieldAccessor.ofBeanProperty())
                     .defineMethod("getRequiredWritePrivilege", String.class, PUBLIC)
                     .intercept(FieldAccessor.ofBeanProperty())
                     .make();

        } catch (NoSuchMethodException e) {
            debugLogger.error("[createDynamicEntityType]", e);
        }

        return Tuples.of(entityType, String.format("(''||id%s)", descriptionFormula), String.format("(''||'id:'||id%s)", searchIndexFormula),includeTypes);
    }

    /**
     * Generates and loads a Spring Data JPA repository interface for a dynamic entity.
     * <p>
     * Creates a {@code SecureRepository} interface at runtime with Spring annotations for JPA repository 
     * factory creation and metadata embedding. The generated interface is ready for 
     * {@code JpaRepositoryFactory.getRepository()} proxy instantiation.
     * </p>
     * 
     * <h3>Generated Interface Structure</h3>
     * <ol>
     * <li><b>Interface Declaration:</b> Creates public interface implementing {@code SecureRepository<T>} 
     * where T is the generated entity class</li>
     * <li><b>{@code @Repository} Annotation:</b> Marks interface as Spring component for component scanning 
     * and exception translation</li>
     * <li><b>{@code @SearchableRepositoryMetadata} Annotation:</b> Embeds metadata for search functionality:
     *   <ul>
     *   <li>{@code entityClass}: Generated entity class reference</li>
     *   <li>{@code entityKey}: Unique entity identifier for runtime lookup</li>
     *   <li>{@code searchIndexFormula}: SQL formula for full-text search indexing</li>
     *   <li>{@code descriptionFormula}: SQL formula for entity display strings</li>
     *   </ul>
     * </li>
     * <li><b>ClassLoader Injection:</b> Loads interface via {@code INJECTION} strategy into provided ClassLoader</li>
     * </ol>
     * 
     * <h3>Repository Capabilities</h3>
     * <p>The generated {@code SecureRepository<T>} interface provides:</p>
     * <ul>
     * <li>Standard Spring Data JPA CRUD operations (findById, save, delete, etc.)</li>
     * <li>Privilege-enforced query methods via {@code SecureRepository} contract</li>
     * <li>Custom query method support via method naming conventions</li>
     * <li>Search functionality via embedded {@code searchIndexFormula}</li>
     * </ul>
     * 
     * <h3>JPA Factory Integration</h3>
     * <p>The loaded interface class is passed to {@code JpaRepositoryFactory.getRepository()} in 
     * {@link #registerDynamicRepositories(boolean)} to create a concrete proxy implementation with 
     * Spring Data query derivation.</p>
     * 
     * <p><b>Byte Buddy Details:</b> Uses {@code ByteBuddy.makeInterface()} with {@code SKIP_DEFAULTS} 
     * attribute filtering, type parameterization via {@code TypeDescription.Generic.Builder.parameterizedType()}, 
     * and annotation embedding via {@code annotateType()}.</p>
     * 
     * @param entity Generated entity class from {@link #createDynamicEntityType}. Must extend 
     *               {@link OpenkodaEntity} and be fully loaded into ClassLoader.
     * @param entityKey Unique entity identifier for metadata embedding. Used by 
     *                  {@code SearchableRepositories} for runtime entity lookup.
     * @param entityDescriptionFormula SQL formula for entity display strings. Generated by 
     *                                 {@link #createDynamicEntityType} as concatenation of text fields.
     * @param searchIndexFormula SQL formula for full-text search indexing. Generated by 
     *                           {@link #createDynamicEntityType} with field labels and COALESCE wrappers.
     * @param repositoryName Repository interface name without package prefix. Format: "FormEntityRepository_1234567890". 
     *                       Full name becomes {@code com.openkoda.dynamicentity.generated.FormEntityRepository_1234567890}.
     * @param cl ClassLoader for repository interface injection. Must be the same ClassLoader used to load 
     *           the entity class to ensure type visibility.
     * @return Generated {@code SecureRepository<T>} interface class ready for {@code JpaRepositoryFactory} 
     *         proxy creation. Can be cast to specific repository type after JPA factory instantiation.
     * @see #buildAndLoadDynamicClasses(ClassLoader)
     * @see #registerDynamicRepositories(boolean)
     * @see SecureRepository
     * @see SearchableRepositoryMetadata
     * @see JpaRepositoryFactory#getRepository(Class)
     * @see net.bytebuddy.ByteBuddy#makeInterface()
     */
    private static <T extends OpenkodaEntity> Class<SecureRepository<T>> createAndLoadDynamicRepository(Class<T> entity,
                                                                                                        String entityKey,
                                                                                                        String entityDescriptionFormula,
                                                                                                        String searchIndexFormula,
                                                                                                        String repositoryName,
                                                                                                        ClassLoader cl) {
        debugLogger.debug("[createAndLoadDynamicRepository] {}", entityKey);

        AnnotationDescription repositoryAnnotation = AnnotationDescription.Builder.ofType(Repository.class)
                .build();
        AnnotationDescription searchableRepositoryAnnotation = AnnotationDescription.Builder.ofType(SearchableRepositoryMetadata.class)
                .define("entityClass", entity)
                .define("entityKey", entityKey)
                .define("searchIndexFormula", searchIndexFormula)
                .define("descriptionFormula", entityDescriptionFormula)
                .build();

        TypeDescription.Generic secureRepositoryType = TypeDescription.Generic.Builder
                .parameterizedType(SecureRepository.class, entity)
                .build();

        DynamicType.Unloaded<?> repositoryType = new ByteBuddy()
                .with(SKIP_DEFAULTS)
                .makeInterface()
                .implement(secureRepositoryType)
                .annotateType(repositoryAnnotation, searchableRepositoryAnnotation)
                .name(PACKAGE + repositoryName)
                .make();

        Class<?> repo = repositoryType
                .load(cl, INJECTION)
                .getLoaded();

        return (Class<SecureRepository<T>>) repo;
    }
    
    /**
     * Marker interface with default {@code notificationMessage()} implementation for audit/notification formatting.
     * <p>
     * Extends {@link CanonicalObject} to provide JSON-like string representation of dynamically-generated 
     * entity instances for logging and notification systems. All generated entity classes implement this 
     * interface via Byte Buddy's {@code .implement(CanonicalObjectInterceptor.class)} directive.
     * </p>
     * 
     * <h3>Default Implementation Behavior</h3>
     * <p>The {@link #notificationMessage()} default method uses reflection to:</p>
     * <ol>
     * <li>Extract entity class simple name (e.g., "FormEntity_1234567890")</li>
     * <li>Invoke {@code getId()} method via reflection to retrieve entity ID</li>
     * <li>Iterate public non-static non-final fields via {@code getDeclaredFields()}</li>
     * <li>Format each field as {@code "fieldName":"fieldValue"} JSON-like pair</li>
     * <li>Assemble into compact string: {@code ClassName{\"id\":123, \"field1\":\"value1\", ...}}</li>
     * </ol>
     * 
     * <h3>Field Filtering</h3>
     * <p>Only includes fields matching ALL criteria:</p>
     * <ul>
     * <li>Public visibility ({@code Modifier.isPublic()})</li>
     * <li>Non-static ({@code !Modifier.isStatic()})</li>
     * <li>Non-final ({@code !Modifier.isFinal()})</li>
     * </ul>
     * <p>This filters out constants, static utilities, and private/protected implementation details.</p>
     * 
     * <h3>Thread Safety</h3>
     * <p>Safe for read-only reflection operations. The method does not modify field values, only reads 
     * them for string formatting. Multiple threads can safely call {@code notificationMessage()} concurrently 
     * on the same entity instance.</p>
     * 
     * <h3>Error Handling</h3>
     * <p>Catches {@code IllegalAccessException}, {@code IllegalArgumentException}, 
     * {@code NoSuchMethodException}, and general {@code Throwable}. On exception, falls back to 
     * {@code this.toString()} to prevent notification failures from breaking application flow.</p>
     * 
     * @see CanonicalObject
     * @see #createDynamicEntityType(String, String, Collection)
     */
    public interface CanonicalObjectInterceptor extends CanonicalObject {

        /**
         * Generates JSON-like string representation of entity for audit trails and notifications.
         * <p>
         * Uses reflection to extract entity ID and all public non-static non-final fields, formatting 
         * them as {@code ClassName{\"id\":123, \"field1\":\"value1\", \"field2\":\"value2\"}}.
         * </p>
         * <p><b>Example Output:</b></p>
         * <pre>
         * FormEntity_1234567890{"id":42, "name":"Sample", "value":"123"}
         * </pre>
         * 
         * @return JSON-like formatted string representing entity state. Falls back to {@code toString()} 
         *         on reflection errors.
         */
        default String notificationMessage() {
            StringBuilder builder = new StringBuilder();
            builder.append(this.getClass().getSimpleName());
            builder.append("{");
            try {
                List<String> fields = java.util.stream.Stream.of(this.getClass().getDeclaredFields())
                        .filter( f -> !java.lang.reflect.Modifier.isFinal(f.getModifiers()) && !java.lang.reflect.Modifier.isStatic(f.getModifiers()) && java.lang.reflect.Modifier.isPublic(f.getModifiers()))
                .map( f -> {
                    try {
                        return String.format("\"%s\":\"%s\"", f.getName(),f.get(this) != null ? f.get(this).toString() : "null");
                    } catch (IllegalArgumentException | IllegalAccessException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                        return "";
                    }
                }).toList();
                
                try {
                    Method idField = this.getClass().getMethod("getId", null);
                    if(idField != null) {
                        builder.append("\"id\" : ");
                        builder.append(idField.invoke(this) != null ? idField.invoke(this).toString() : "null");
                        builder.append(", ");
                    }
                } catch(NoSuchMethodException exc) {
                    exc.printStackTrace();
                }
                
                builder.append(String.join(", ", fields));
                builder.append("}");
    
                return builder.toString();
            }catch (Throwable exc) {
                exc.printStackTrace();
                return this.toString();
            }
        }   
    }

    /**
     * Creates a parameterized {@code List<T>} type description for Byte Buddy field definitions.
     * <p>
     * Constructs a {@code TypeDescription.Generic} representing {@code java.util.List<T>} where T is 
     * the provided class parameter. Used to define collection fields such as {@code List<File>} for 
     * file attachments and {@code List<Long>} for file ID collections.
     * </p>
     * 
     * @param c Element type for the list. Example: {@code File.class} produces {@code List<File>}, 
     *          {@code Long.class} produces {@code List<Long>}.
     * @return Parameterized type description ready for Byte Buddy {@code defineField()} method.
     * @see #createDynamicEntityType(String, String, Collection)
     * @see TypeDescription.Generic.Builder#parameterizedType(Class, Class...)
     */
    private static TypeDescription.Generic listOfType(Class c){
        return TypeDescription.Generic.Builder.parameterizedType(List.class, c).build();
    }

    /**
     * Maps {@code FrontendMappingFieldDefinition} field type to Java class for JPA field generation.
     * <p>
     * Translates {@code FieldType} enum values from form definitions to corresponding Java types 
     * for entity class field declarations. Handles all standard database column types.
     * </p>
     * 
     * <h3>Type Mapping</h3>
     * <ul>
     * <li>{@code FieldType.text} (VARCHAR) → {@code String.class}</li>
     * <li>{@code FieldType.bigint} (BIGINT) → {@code Long.class}</li>
     * <li>{@code FieldType.numeric} (NUMERIC) → {@code BigDecimal.class}</li>
     * <li>{@code FieldType.boolean} (BOOLEAN) → {@code Boolean.class}</li>
     * <li>{@code FieldType.date} (DATE) → {@code LocalDate.class}</li>
     * <li>{@code FieldType.timestamp_w_tz} (TIMESTAMP WITH TIME ZONE) → {@code LocalDateTime.class}</li>
     * <li>{@code FieldType.time_w_tz} (TIME WITH TIME ZONE) → {@code LocalTime.class}</li>
     * <li>Other VARCHAR variants → {@code String.class}</li>
     * </ul>
     * 
     * @param field Field definition containing type information from {@code FrontendMappingDefinition}.
     * @return Java class to use for field declaration. Returns {@code null} for unmapped types.
     * @see #createDynamicEntityType(String, String, Collection)
     * @see FieldType
     * @see FrontendMappingFieldDefinition
     */
    private static Type getFieldJavaType(FrontendMappingFieldDefinition field) {
        if (field.type.getDbType().getColumnType().equals("varchar")) {
            return String.class;
        }
        return switch (field.type.getDbType()) {
            case BIGINT -> Long.class;
            case NUMERIC -> BigDecimal.class;
            case BOOLEAN -> Boolean.class;
            case DATE -> LocalDate.class;
            case TIMESTAMP_W_TZ -> LocalDateTime.class;
            case TIME_W_TZ -> LocalTime.class;
            default -> null;
        };
    }

    /**
     * Generates JavaBean getter method name for a field.
     * <p>
     * Constructs getter name following JavaBean naming conventions: {@code "get" + capitalizedFieldName}.
     * Delegates to {@link #capitalize(String)} to handle edge cases like fields starting with multiple 
     * uppercase letters (e.g., "URLField" → "getURLField" not "getURLfield").
     * </p>
     * 
     * @param fieldName Field name to generate getter for. Example: "userName" → "getUserName", 
     *                  "id" → "getId", "URLField" → "getURLField".
     * @return JavaBean getter method name with "get" prefix and capitalized field name.
     * @see #capitalize(String)
     * @see #createDynamicEntityType(String, String, Collection)
     */
    private static String getGetterName(String fieldName){
        return "get" + capitalize(fieldName);
    }

    /**
     * Generates JavaBean setter method name for a field.
     * <p>
     * Constructs setter name following JavaBean naming conventions: {@code "set" + capitalizedFieldName}.
     * Delegates to {@link #capitalize(String)} to handle edge cases.
     * </p>
     * 
     * @param fieldName Field name to generate setter for. Example: "userName" → "setUserName", 
     *                  "id" → "setId", "URLField" → "setURLField".
     * @return JavaBean setter method name with "set" prefix and capitalized field name.
     * @see #capitalize(String)
     * @see #createDynamicEntityType(String, String, Collection)
     */
    private static String getSetterName(String fieldName){
        return "set" + capitalize(fieldName);
    }

    /**
     * Capitalizes field name with special handling for acronyms and multi-letter uppercase prefixes.
     * <p>
     * Implements smart capitalization logic for JavaBean accessor generation:
     * </p>
     * <ul>
     * <li><b>Standard case:</b> "userName" → "UserName" (capitalize first letter)</li>
     * <li><b>Already capitalized:</b> "UserName" → "UserName" (no change)</li>
     * <li><b>Acronym prefix:</b> "URLField" → "URLField" (preserve if second char is uppercase)</li>
     * <li><b>Single letter:</b> "x" → "X" (simple capitalization)</li>
     * </ul>
     * 
     * <h3>Edge Case Handling</h3>
     * <p>
     * The method checks if the second character (index 1) is already uppercase. If so, returns the field 
     * name unchanged to preserve acronyms. This ensures {@code "URLField"} generates {@code "getURLField"} 
     * not {@code "getURLfield"}, maintaining readability for acronyms.
     * </p>
     * 
     * @param fieldName Field name to capitalize. Must be non-null and non-empty.
     * @return Capitalized field name suitable for JavaBean accessor methods.
     * @see #getGetterName(String)
     * @see #getSetterName(String)
     * @see StringUtils#capitalize(String)
     */
    private static String capitalize(String fieldName){
        if(fieldName.length() > 1 && isUpperCase(fieldName.charAt(1))){
            return fieldName;
        }
        return StringUtils.capitalize(fieldName);

    }
}